
电子科技大学成都学院 计算机 系




标 准 实 验 报 告




（实验）课程名称  数字图像处理






电子科技大学成都学院计算机系制表


电 子 科 技 大 学成都学院
实   验   报   告
组员学号、姓名：   
2041340319 黄慨然
2041340322 陈叶凯
2041340318李佳晟
2041340312 张钦君
2041340314张辉
2041340324 张耀中
2041340315 余骏驰

指导教师：陈东祥
              
一、实验背景：
随着科技的发展，电子与计算机技术的进步，答题卡的出现大大减轻教学工作者们批改试卷的工作量。答题卡是光标阅读机输入信息的载体，是配套光标阅读机的各种信息录入表格的总称。 答题卡将用户需要的信息转化为可选择的选项，供用户涂写。OMR是用光学扫描的方法来识别按一定格式印刷或书写的标记，并将其转换为计算机能接受的电信号的设备，并根据信息点的涂与未涂和格式文件设置将信息还原。因此，如何将答题卡填涂的黑色区域识别出来并使用计算机进行处理是极为关键的。本文探索了有效识别答题卡的方法，以matlab为工具，基于数字图像处理技术对答题卡填涂区域进行了识别，并对识别的结果进行了处理，得到了结果。最终实现答题卡答案的定位和检测。本文使用像素统计方法进行识别，利用黑白颜色灰度值的巨大差异对二值图像的灰度值进行累加并进行阈值判定，识别错误效率极低，能够准确的识别答题卡的涂卡标记。
二、实验内容：
提供一张答题卡图像，通过图像处理识别出答题卡上每个题的选项，与正确答案对比，得出分数并写在答题卡上。
三、实验步骤及原理：
1.安装并引入需要的库
本实验作为一个简单的答题卡识别实验，这里只需要用到numpy和opencv。
简单介绍一下什么是numpy，numpy用来做什么：NumPy（Numerical Python）是Python的一种开源的数值计算扩展。这种工具可用来存储和处理大型矩阵，比Python自身的嵌套列表（nested list structure)结构要高效的多（该结构也可以用来表示矩阵（matrix）），支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。
Opencv：OpenCV是一个基于Apache2.0许可（开源）发行的跨平台计算机视觉和机器学习软件库，可以运行在Linux、Windows、Android和Mac OS操作系统上。它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。
首先要在自己的环境中安装numpy和opencv，下面是下载的相关命令：
pip install numpy
pip install opencv-python
pip install opencv-contrib-python
然后在代码中引入这两个库：
import numpy as np
import cv2 as cv
如图所示：



2.定义绘图函数
如图所示：



3.输入正确答案
设置一个字典结构用来表示正确答案，如下图所示：

如图第一题正确答案是第二个选项（B），第二题是第五个（E），第三	题是第一个（A），第四题是第四个（D），第五题是第二个（B）


4.传入答题卡图像


使用cv.imread()方法直接读取图片，并将其保存在变量image中。
用cv_show()，输出图片并命名为image。
图片如下图：

5.对图像进行高斯滤波
高斯滤波是一种线性平滑滤波，适用于消除高斯噪声，广泛应用于图像处理的减噪过程。通俗的讲，高斯滤波就是对整幅图像进行加权平均的过程，每一个像素点的值，都由其本身和邻域内的其他像素值经过加权平均后得到。高斯滤波的具体操作是：用一个模板（或称卷积、掩模）扫描图像中的每一个像素，用模板确定的邻域内像素的加权平均灰度值去替代模板中心像素点的值。

cv.CvtColor函数此函数的作用是将一个图像从一个颜色空间转换到另一个	颜色空间。
且RGB色彩空间在opencv中默认通道顺序为BGR，将RGB颜色转换为	GRAY，同时注意opencv的版本，在2.x版本中前缀为cv_，而在3.x版本中	前缀为COLOR_，因此要注意版本以防使用错误
blurred = cv2.GaussianBlur(gray, (blur1, blur2), 0)
其中gray是要进行滤波的原图像，（5，5）是高斯核的大小，
高斯核的选取一般是奇数，高斯核也可以不同。参数0表示标准差取0。
当blur1=blur2=1时，相当于不对原始图像做操作。blur1和blur2越大，	图像的模糊程度越大。但不是blur1和blur2越大越好，
blur1和blur2太大，不仅会滤除噪音，还会平滑掉图像中有用的信息。所	以blur的选取要进行测试。
如果要进行滤波的图像的长宽比大致为1:1，那么选取blur时，一般设置	blur1=blur2。
如果要进行滤波的图像的长宽比大致为m:n，那么选取blur时，	blur1:blur2=m:n
这里我们选择5：5。
得到滤波后的图像：


6.边缘检测
说到边缘检测，先介绍一下什么是canny算法：
Canny边缘检测算法是John F.Canny于1986年开发出来的一个多级边缘	检测算法，此算法被很多人认为是边缘检测的最优算法，相对其他边缘	检测算法来说其识别图像边缘的准确度要高很多。
最优边缘检测的特征：
1）.低错误率: 标识出尽可能多的实际边缘，同时尽可能的减少噪声					  产生的误报。
2）.高定位性: 标识出的边缘要与图像中的实际边缘尽可能接近。
3）.最小响应: 图像中的边缘只能标识一次。
边缘检测直接用canny检测算法，然后直接把边缘检测后的图像显示出来，在使用canny检测算法之前先需要用滤波进行除噪，一般选择高斯滤波，高斯滤波可以将图像中的噪声部分过滤出来，避免后面进行边缘检测时将错误的噪声信息也误识别为边缘了。

得到边缘检测结果如下图所示：


7.轮廓检测
为了完成透视变换，需要检测出图像的外轮廓。
轮廓检测使用cv.findContours函数，第三个参数一般用		cv.CHAIN_APPROX_SIMPLE，表示用尽可能少的像素点表示轮廓。
cv.drawContours绘制轮廓
第一个参数是指明在哪幅图像上绘制轮廓；	image为三通道才能显示轮廓
	第二个参数是轮廓本身，在Python中是一个list;
	第三个参数指定绘制轮廓list中的哪条轮廓，如果是-1，则绘制其	中的所有轮廓。后面的参数很简单。其中thickness表明轮廓线的宽度，	如果是-1（cv2.FILLED），则为填充模式。

得到如下图所示结果：



8.得到近似多边形的点坐标
由于轮廓检测返回的轮廓是由89个点构成的，而我们需要进行的透视变	换只需要4个点（左上，右上，右下，左下）的位置即可完成，故需要找到此外轮廓的近似多边形的坐标。


9.将得到的点坐标按照左上右上右下左下排序
为了使现在得到的点与投射完成后的点的位置一一对应，在这里要先将这些点按一定顺序排列。




10.获取变换后对应坐标位置
变换后，图像的长和宽应该变为：
	长（w值） = max（变换前左边长，变换前右边长）
	宽（h值） = max（变换前上边长，变换前下边长）
	设变换后图像的左上角位置为原点位置。
代码如下图所示：


11.计算变换矩阵并作透视变换
在获取图像后需要将这个图片摆正，所以要用到透视变换。
	透视变换是指利用透视中心、像点、目标点三点共线的条件，按透视旋	转定律使承影面（透视面）绕迹线（透视轴）旋转某一角度，破坏原有	的投影光线束，仍能保持承影面上投影几何图形不变的变换。
	返回由源图像中矩形到目标图像矩形变换的矩阵，得到矩阵得有用才行，	所以要做变换矩阵。
如下图所示：


得到的变换后的图像：

12.对变换后的图像进行阈值处理
阀值处理后使图象只有几种颜色如最通常的分为了黑白的二值图象
黑表示背景白表示选择则可以进行进一步的工作.
阈值处理就是剔除图像内像数值高于或低于一定值的像素点。可以获	得一个二值图，有效的实现的前景和背景的分离。


如下图所示得到二值图像：




13.找到轮廓并将它们涂黑


得到82个轮廓，存放在列表cnts中。
	
得到图像：


14.找到包含选项的25个圆形轮廓
先找出所有轮廓的近似矩形。
计算矩形的长和宽，按照一定标准进行筛选。

如前面的答题卡原图所示，所有的选项都是圆形的，我们找出所有轮廓（圆）	的近似矩阵，计算矩形的长（w）和宽（h），上图所示ar=w/h即为搜索标	准，长和宽的比值，因为所有的矩阵（圆的近似矩阵）都是标准的大小几乎	一致所以在后面中设置所有的ar都小于等于1.1（可能存在些许误差）
而w和h大于等于20则是我们设置的一个值，这个根据不同需要设置不同	的值，本次实验中因为是圆所以w和h应该几乎是相等的。

15.对25个圆形轮廓按照从上到下进行排序，划分出5组（即代表五道题）
如下图所示，这是两种排序方式，上面的那种是使用的相关函数（zip、lambda等），而下面的那个则是用传统的方式排序。


16.得到结果
1.对每组中的5个选项所代表的轮廓进行排序。
2.制作一个mask来遍历每一个选项。
3.制作一个全黑mask。
什么是掩膜（mask）
数字图像处理中的掩膜的概念是借鉴于PCB制版的过程，在半导体制造中，许多芯片工艺步骤采用光刻技术，用于这些步骤的图形“底片”称为掩膜（也称作“掩模”），其作用是：在硅片上选定的区域中对一个不透明的图形模板遮盖，继而下面的腐蚀或扩散将只影响选定的区域以外的区域。
图像掩膜与其类似，用选定的图像、图形或物体，对处理的图像（全部或局部）进行遮挡，来控制图像处理的区域或处理过程。
光学图像处理中,掩模可以是胶片、滤光片等。数字图像处理中,掩模为二维矩阵数组,有时也用多值图像。数字图像处理中,图像掩模主要用于：
①提取感兴趣区,用预先制作的感兴趣区掩模与待处理图像相乘,得到感兴趣区图像,感兴趣区内图像值保持不变,而区外图像值都为0。
②屏蔽作用,用掩模对图像上某些区域作屏蔽,使其不参加处理或不参加处理参数的计算,或仅对屏蔽区作处理或统计。
③结构特征提取,用相似性变量或图像匹配方法检测和提取图像中与掩模相似的结构特征。
④特殊形状图像的制作。
掩膜是一种图像滤镜的模板，实用掩膜经常处理的是遥感图像。当提取道路或者河流，或者房屋时，通过一个n*n的矩阵来对图像进行像素过滤，然后将我们需要的地物或者标志突出显示出来。这个矩阵就是一种掩膜。
4.用25个圆形轮廓对mask进行填充（一次只用一个轮廓）。
5.用填充完的mask对图像进行与操作，遍历后会得到25个只包含一个	  选项的图像。
6.每5组图像进行比较，由于被选的选项的白色区域更多，所以通过计	  算非零点数量来判断考生选择的答案。
7.与正确答案进行对比，得出分数。






17.将结果写在答题卡上



三、实验结果


如图所示通过上面设置的正确题号与图中涂黑部分对比得到答题正确率为80%


四、实验总结
本文主要研究基于图像处理的答题卡识别，考虑到答题卡图像在获取方式的不同和考试方式的多样性，普通答题卡识别系统对图像的适应性比较单一难以满足考试多样性的需求，如何使本文主要研究基于图像处理的答题卡智能识别中的关键技术。由于答题卡图像在获取方式的不同与考试方式的多样性，普通的答题卡识别系统对图像的适应性比较单一难以满足考试多样性的需求，如何使答题卡识别技术可以更广泛的适用于各种类型的答题卡来达到智能识别是答题卡识别研究的主要问题。本文针对这一问题做了以下方面的研究:
(1).本文通过对答题卡识别的发展现状进行了分析，明确了本课题的研究目的和意义，为后续的研究提供了帮助。
(2).通过使用图像中像素点的投影技术，实现了答题卡客观题与学生信息选项区域的分割与定位，使用Hough 变换与傅里叶变换实现了对倾斜的答题卡图像的矫正，使用图像的边缘检测与图像的透射变换完成了对图像的形变矫正。




                                                     报告评分：
                                      指导教师签字：
